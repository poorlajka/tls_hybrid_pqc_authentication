#include <array>
#include <vector>

#include "test.hpp"

#include "prgs.hpp"
#include "util.hpp"
#include "vector_com.hpp"
#include "vector_com.inc"
#include "vole_commit.inc"
#include "vole_key_index_permutation.hpp"

#include "test_bavc_tvs.hpp"

#include <catch2/catch_template_test_macros.hpp>
#include <catch2/catch_test_macros.hpp>

template <secpar S> using arr_secpar = std::array<uint8_t, secpar_to_bytes(S)>;
template <typename BAVC> using arr_leaf_hash = std::array<uint8_t, BAVC::leaf_hash_t::hash_len>;

#define BAVC_TEST_INSTANCES                                                                        \
    (ggm_forest_bavc<secpar::s128, 11, 128, prg::aes_ctr, leaf_hash::shake, 3>),                   \
    (ggm_forest_bavc<secpar::s128, 16, 128, prg::aes_ctr, leaf_hash::shake, 3>),                   \
    (ggm_forest_bavc<secpar::s192, 16, 192, prg::aes_ctr, leaf_hash::shake, 3>),                   \
    (ggm_forest_bavc<secpar::s192, 24, 192, prg::aes_ctr, leaf_hash::shake, 3>),                   \
    (ggm_forest_bavc<secpar::s256, 22, 256, prg::aes_ctr, leaf_hash::shake, 3>),                   \
    (ggm_forest_bavc<secpar::s256, 32, 256, prg::aes_ctr, leaf_hash::shake, 3>),                   \
    (ggm_forest_bavc<secpar::s128, 11, 120, prg::aes_ctr, leaf_hash::shake, 3>),                   \
    (ggm_forest_bavc<secpar::s128, 11, 111, prg::aes_ctr, leaf_hash::shake, 3>),                   \
    (ggm_forest_bavc<secpar::s128, 11, 100, prg::aes_ctr, leaf_hash::shake, 3>),                   \
    (ggm_forest_bavc<secpar::s128, 11, 128, prg::aes_ctr, leaf_hash::aes_ctr_stat_bind, 3>),       \
    (ggm_forest_bavc<secpar::s128, 16, 128, prg::aes_ctr, leaf_hash::aes_ctr_stat_bind, 3>),       \
    (ggm_forest_bavc<secpar::s192, 16, 192, prg::aes_ctr, leaf_hash::aes_ctr_stat_bind, 3>),       \
    (ggm_forest_bavc<secpar::s192, 24, 192, prg::aes_ctr, leaf_hash::aes_ctr_stat_bind, 3>),       \
    (ggm_forest_bavc<secpar::s256, 22, 256, prg::aes_ctr, leaf_hash::aes_ctr_stat_bind, 3>),       \
    (ggm_forest_bavc<secpar::s256, 32, 256, prg::aes_ctr, leaf_hash::aes_ctr_stat_bind, 3>),       \
    (ggm_forest_bavc<secpar::s128, 11, 120, prg::aes_ctr, leaf_hash::aes_ctr_stat_bind, 3>),       \
    (ggm_forest_bavc<secpar::s128, 11, 111, prg::aes_ctr, leaf_hash::aes_ctr_stat_bind, 3>),       \
    (ggm_forest_bavc<secpar::s128, 11, 100, prg::aes_ctr, leaf_hash::aes_ctr_stat_bind, 3>)

TEMPLATE_TEST_CASE("commit/open/verify", "[vector com]", BAVC_TEST_INSTANCES)
{
    using bavc_t = TestType;
    using VC = bavc_t::CONSTS;
    constexpr auto S = bavc_t::secpar_v;
    constexpr auto TAU = bavc_t::tau_v;
    constexpr auto VOLE_WIDTH_SHIFT = bavc_t::vole_width_shift_v;

    block_secpar<S> seed = rand<block_secpar<S>>();
    std::vector<block_secpar<S>> forest(bavc_t::COMMIT_NODES);
    std::vector<block_secpar<S>> leaves_sender(bavc_t::COMMIT_LEAVES);
    std::vector<block_secpar<S>> leaves_receiver(bavc_t::COMMIT_LEAVES);
    std::vector<unsigned char> hashed_leaves_sender(bavc_t::COMMIT_LEAVES * bavc_t::leaf_hash_t::hash_len);
    std::vector<unsigned char> hashed_leaves_receiver(bavc_t::COMMIT_LEAVES * bavc_t::leaf_hash_t::hash_len);

    const size_t delta = 42 % (1 << VC::MIN_K);

    std::vector<uint8_t> delta_bytes(bavc_t::delta_bits_v, 0);
    for (size_t i = 0, dst = 0; i < TAU; ++i)
    {
        size_t k = i < VC::NUM_MAX_K ? VC::MAX_K : VC::MIN_K;
        expand_bits_to_bytes(&delta_bytes[dst], k, delta);
        dst += k;
    }

    block128 iv = rand<block128>();

    std::vector<unsigned char> opening(bavc_t::OPEN_SIZE);

    bavc_t::commit(seed, iv, forest.data(), leaves_sender.data(), hashed_leaves_sender.data());
    const auto res_open = bavc_t::open(forest.data(), hashed_leaves_sender.data(),
                                       delta_bytes.data(), opening.data());
    REQUIRE(res_open);
    const auto res_verify = bavc_t::verify(iv, opening.data(), delta_bytes.data(),
                                           leaves_receiver.data(), hashed_leaves_receiver.data());
    REQUIRE(res_verify);

    const auto hashed_leaves_sender_bytes =
        std::vector(reinterpret_cast<arr_leaf_hash<bavc_t>*>(hashed_leaves_sender.data()),
                    reinterpret_cast<arr_leaf_hash<bavc_t>*>(hashed_leaves_sender.data() +
                                                             hashed_leaves_sender.size()));
    const auto hashed_leaves_receiver_bytes =
        std::vector(reinterpret_cast<arr_leaf_hash<bavc_t>*>(hashed_leaves_receiver.data()),
                    reinterpret_cast<arr_leaf_hash<bavc_t>*>(hashed_leaves_receiver.data() +
                                                             hashed_leaves_receiver.size()));
    REQUIRE(hashed_leaves_receiver_bytes == hashed_leaves_sender_bytes);

    for (size_t i = 0, src = 0; i < TAU; ++i)
    {
        size_t k = i < VC::NUM_MAX_K ? VC::MAX_K : VC::MIN_K;
        for (size_t j = 0; j < (size_t)1 << k; ++j)
        {
            if (j == delta)
                continue;

            arr_secpar<S> sender_leaf, receiver_leaf;
            memcpy(&sender_leaf,
                   &leaves_sender[src + vole_permute_key_index_inv<VOLE_WIDTH_SHIFT, VC::MAX_K>(j)],
                   sender_leaf.size());
            memcpy(&receiver_leaf,
                   &leaves_receiver[src + vole_permute_key_index_inv<VOLE_WIDTH_SHIFT, VC::MAX_K>(
                                              j ^ delta)],
                   receiver_leaf.size());
            INFO(i);
            INFO(j);
            REQUIRE(sender_leaf == receiver_leaf);
        }

        src += (size_t)1 << k;
    }
}

using test_grind_bavc_1 = ggm_forest_bavc<secpar::s128, 11, 128, prg::aes_ctr, leaf_hash::shake, 3>;
using test_grind_bavc_2 = ggm_forest_bavc<secpar::s128, 11, 121, prg::aes_ctr, leaf_hash::shake, 3>;
using test_grind_bavc_3 = one_tree_bavc<secpar::s128, 11, 128, prg::aes_ctr, leaf_hash::shake, 3, 98>;
using test_grind_bavc_4 = one_tree_bavc<secpar::s128, 11, 121, prg::aes_ctr, leaf_hash::shake, 3, 98>;
#define BAVC_TEST_INSTANCES_WITH_GRINDING                                                          \
    test_grind_bavc_1, test_grind_bavc_2, test_grind_bavc_3, test_grind_bavc_4

TEMPLATE_TEST_CASE("commit/grind_open/verify", "[vector com]", BAVC_TEST_INSTANCES_WITH_GRINDING)
{
    using bavc_t = TestType;
    using VC = bavc_t::CONSTS;
    constexpr auto S = bavc_t::secpar_v;
    constexpr auto TAU = bavc_t::tau_v;
    constexpr auto VOLE_WIDTH_SHIFT = bavc_t::vole_width_shift_v;

    block_secpar<S> seed = rand<block_secpar<S>>();
    std::vector<block_secpar<S>> forest(bavc_t::COMMIT_NODES);
    std::vector<block_secpar<S>> leaves_sender(bavc_t::COMMIT_LEAVES);
    std::vector<block_secpar<S>> leaves_receiver(bavc_t::COMMIT_LEAVES);
    std::vector<unsigned char> hashed_leaves_sender(bavc_t::COMMIT_LEAVES * bavc_t::leaf_hash_t::hash_len);
    std::vector<unsigned char> hashed_leaves_receiver(bavc_t::COMMIT_LEAVES * bavc_t::leaf_hash_t::hash_len);

    std::array<uint8_t, bavc_t::delta_bytes_v> delta = {0};
    std::array<uint8_t, bavc_t::delta_bits_v> delta_bytes = {0};
    block128 iv = rand<block128>();
    std::vector<uint8_t> opening(bavc_t::OPEN_SIZE);

    bavc_t::commit(seed, iv, forest.data(), leaves_sender.data(), hashed_leaves_sender.data());

    // Initialize a 4x hasher and hash the common input prefix.
    hash_state_x4 grinding_hasher;
    grinding_hasher.init(S);
    grinding_hasher.update_1_byte(0x42);
    uint32_t counter;
    bool res_open =
        grind_and_open<bavc_t>(forest.data(), hashed_leaves_sender.data(), delta.data(),
                               opening.data(), &grinding_hasher, &counter);
    REQUIRE(res_open);

    // Expand Delta to have one byte per bit
    for (size_t i = 0; i < bavc_t::delta_bits_v; ++i)
        delta_bytes[i] = expand_bit_to_byte(delta[i / 8], i % 8);

    // Check that Delta is computed correctly
    {
        std::array<uint8_t, secpar_to_bytes(S)> recomputed_hash;
        hash_state hasher;
        hasher.init(S);
        hasher.update_byte(0x42);
        hasher.update_byte(counter);
        hasher.update_byte(counter >> 8);
        hasher.update_byte(counter >> 16);
        hasher.update_byte(counter >> 24);
        hasher.update_byte(8 + 3);
        hasher.finalize(recomputed_hash.data(), recomputed_hash.size());

        std::array<uint8_t, secpar_to_bits(S)> recomputed_delta_bytes;
        expand_bits_to_bytes(recomputed_delta_bytes.data(), secpar_to_bits(S), recomputed_hash.data());

        for (size_t i = 0; i < bavc_t::delta_bits_v; ++i) {
            INFO("i = " << i);
            INFO("delta_bytes = " << delta_bytes);
            INFO("recomputed_delta_bytes = " << recomputed_delta_bytes);
            REQUIRE(recomputed_delta_bytes[i] == delta_bytes[i]);
        }
        for (size_t i = bavc_t::delta_bits_v; i < secpar_to_bits(S); ++i) {
            INFO("i = " << i);
            INFO("recomputed_delta_bytes = " << recomputed_delta_bytes);
            REQUIRE(recomputed_delta_bytes[i] == 0);
        }
    }


    const auto res_verify = bavc_t::verify(iv, opening.data(), delta_bytes.data(),
                                           leaves_receiver.data(), hashed_leaves_receiver.data());
    REQUIRE(res_verify);

    const auto hashed_leaves_sender_bytes =
        std::vector(reinterpret_cast<arr_leaf_hash<bavc_t>*>(hashed_leaves_sender.data()),
                    reinterpret_cast<arr_leaf_hash<bavc_t>*>(hashed_leaves_sender.data() +
                                                             // 3));
                                                             hashed_leaves_sender.size()));
    const auto hashed_leaves_receiver_bytes =
        std::vector(reinterpret_cast<arr_leaf_hash<bavc_t>*>(hashed_leaves_receiver.data()),
                    reinterpret_cast<arr_leaf_hash<bavc_t>*>(hashed_leaves_receiver.data() +
                                                             // 3));
                                                             hashed_leaves_receiver.size()));
    REQUIRE(hashed_leaves_receiver_bytes == hashed_leaves_sender_bytes);

    size_t delta_bits_ctr = 0;
    for (size_t i = 0, src = 0; i < TAU; ++i)
    {
        size_t k = i < VC::NUM_MAX_K ? VC::MAX_K : VC::MIN_K;
        size_t delta = 0;
        for (size_t j = 0; j < k; ++j) {
            delta |= (delta_bytes.at(delta_bits_ctr) & 1) << j;
            FAEST_ASSERT(delta_bits_ctr < bavc_t::delta_bits_v);
            ++delta_bits_ctr;
        }
        REQUIRE(delta < (size_t{1} << k));
        INFO("i = " << i);
        INFO("k_i = " << k);
        INFO("Delta_" << i << " = " << delta);
        for (size_t j = 0; j < (size_t)1 << k; ++j)
        {
            if (j == delta)
                continue;

            arr_secpar<S> sender_leaf, receiver_leaf;
            memcpy(&sender_leaf,
                   &leaves_sender[src + vole_permute_key_index_inv<VOLE_WIDTH_SHIFT, VC::MAX_K>(j)],
                   sender_leaf.size());
            memcpy(&receiver_leaf,
                   &leaves_receiver[src + vole_permute_key_index_inv<VOLE_WIDTH_SHIFT, VC::MAX_K>(
                                              j ^ delta)],
                   receiver_leaf.size());
            INFO("j = " << j);
            REQUIRE(sender_leaf == receiver_leaf);
        }

        src += (size_t)1 << k;
    }
}

using test_params_128 = parameter_set<secpar::s128, 32, owf::aes_ecb /* doesn't matter */,
                                      prg::aes_ctr /* doesn't matter */, prg::aes_ctr, leaf_hash::shake>;
using test_params_192 = parameter_set<secpar::s192, 48, owf::aes_ecb /* doesn't matter */,
                                      prg::aes_ctr /* doesn't matter */, prg::aes_ctr, leaf_hash::shake>;
using test_params_256 = parameter_set<secpar::s256, 52, owf::aes_ecb /* doesn't matter */,
                                      prg::aes_ctr /* doesn't matter */, prg::aes_ctr, leaf_hash::shake>;

template <typename P> struct tvs;

// clang-format off

template <>
struct tvs<test_params_128> {
    // test vectors from faest-ref
    constexpr static unsigned int test_vectors = 4;
    constexpr static unsigned int depth = 4;
    static_assert(depth == test_params_128::CONSTS::VEC_COM::MAX_K);

    constexpr static std::array<uint8_t, test_params_128::secpar_bytes> root_key{
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    };
    // the hashed leaves
    constexpr static std::array<uint8_t, (1 << depth) * test_params_128::secpar_bytes * 2> com{
        0x8c, 0xee, 0xbb, 0x29, 0xff, 0x00, 0x29, 0xd5, 0xc0, 0x47, 0xce, 0x99, 0x5d, 0xea, 0x94,
        0x79, 0x54, 0xee, 0xdf, 0xa7, 0x04, 0x3b, 0x92, 0x53, 0x00, 0x84, 0x60, 0xbf, 0x3c, 0x1c,
        0x0d, 0x15, 0x1d, 0x5c, 0x77, 0xba, 0xf7, 0xed, 0x55, 0xa1, 0xa3, 0x85, 0x2e, 0x4e, 0x78,
        0x10, 0x31, 0x28, 0x06, 0xa0, 0xfb, 0xfc, 0xf7, 0x3b, 0x91, 0x85, 0xcc, 0x80, 0x37, 0x16,
        0x38, 0x1a, 0xe0, 0x78, 0x84, 0xe4, 0xfe, 0x97, 0xe3, 0x22, 0x07, 0xe1, 0x75, 0xdb, 0x16,
        0x17, 0xb9, 0x22, 0x3b, 0x26, 0x55, 0x10, 0x28, 0x41, 0x2f, 0x6f, 0xa7, 0xfd, 0x1b, 0x36,
        0x77, 0x61, 0x7b, 0x2d, 0x79, 0x06, 0x5f, 0xbe, 0x2d, 0xfa, 0x20, 0x3f, 0x2d, 0x56, 0x3c,
        0x3e, 0x23, 0xa1, 0xec, 0xc5, 0xa4, 0xcc, 0x9d, 0x95, 0x6a, 0xc0, 0xe7, 0x97, 0xef, 0x49,
        0xe0, 0x6d, 0x10, 0x65, 0x16, 0x8c, 0x80, 0xa6, 0xfb, 0xdd, 0xf6, 0x83, 0x45, 0x59, 0x31,
        0xbc, 0x62, 0x29, 0x33, 0x5d, 0x89, 0x4e, 0x6f, 0x8c, 0x3c, 0x27, 0x37, 0x6a, 0xc1, 0x3f,
        0x11, 0x7f, 0x6a, 0x03, 0x62, 0x59, 0xc8, 0x5d, 0xf5, 0x05, 0x3a, 0x0a, 0x8e, 0xfa, 0x15,
        0x64, 0x6e, 0x90, 0xa0, 0x1d, 0x42, 0x34, 0x38, 0x57, 0xa7, 0x66, 0x7b, 0x92, 0xd1, 0x85,
        0x3d, 0xf4, 0x25, 0x7e, 0x42, 0xe1, 0xfb, 0x84, 0x9f, 0xcd, 0x75, 0xec, 0x0d, 0xb9, 0xba,
        0xd6, 0x69, 0x71, 0x9e, 0xfd, 0x66, 0x32, 0xa2, 0x81, 0x77, 0x8f, 0x89, 0x3f, 0x51, 0x64,
        0xc1, 0x7f, 0xe1, 0xc5, 0xa6, 0x11, 0xba, 0x48, 0x6b, 0x94, 0xf5, 0x91, 0xb8, 0x14, 0x18,
        0x67, 0x0a, 0x30, 0xe9, 0xe1, 0x4f, 0x3c, 0x98, 0x88, 0x54, 0x0d, 0x74, 0x68, 0x5e, 0x22,
        0x86, 0x2b, 0x80, 0xff, 0xbe, 0x36, 0x76, 0x08, 0x98, 0xdf, 0x66, 0x54, 0x89, 0x63, 0x6a,
        0xb2, 0x8e, 0x89, 0xd3, 0x61, 0xa0, 0x86, 0x43, 0xc2, 0xec, 0x6a, 0xc1, 0x20, 0xdc, 0x64,
        0x46, 0x42, 0x83, 0x5d, 0xdc, 0xd1, 0xef, 0xc9, 0x2e, 0xad, 0xe3, 0x1a, 0xda, 0xc9, 0xa9,
        0xe6, 0x5c, 0x0a, 0x16, 0x06, 0x2d, 0x91, 0xb7, 0x89, 0xf3, 0x32, 0x16, 0x14, 0x1e, 0xb7,
        0x6f, 0x0b, 0xd3, 0x0b, 0x49, 0x1b, 0xff, 0x1d, 0xf5, 0xd2, 0x99, 0xa1, 0xa4, 0x9f, 0x16,
        0x61, 0xee, 0xda, 0x96, 0xcc, 0xe1, 0x5f, 0x5a, 0xbb, 0x34, 0xf8, 0x17, 0xf4, 0xbc, 0x79,
        0xfc, 0xb8, 0x60, 0xb5, 0x52, 0xef, 0x61, 0x96, 0x68, 0xa1, 0xb5, 0xbe, 0xdf, 0xc4, 0x3e,
        0x1a, 0x63, 0x6a, 0xd3, 0xf9, 0x5f, 0xf7, 0xa3, 0xab, 0x95, 0x6b, 0x27, 0xf4, 0x5d, 0xd0,
        0x86, 0x72, 0x03, 0x69, 0x02, 0x0c, 0xf0, 0xb5, 0x16, 0x8d, 0x87, 0xda, 0x17, 0xb2, 0x0b,
        0xeb, 0x59, 0xbd, 0x00, 0xe9, 0x24, 0xfe, 0x63, 0xdf, 0x4a, 0x1a, 0x00, 0xb9, 0x02, 0x97,
        0x96, 0x64, 0x19, 0xf3, 0xb8, 0xe4, 0x76, 0x05, 0x3b, 0x91, 0x12, 0xd9, 0xe5, 0xcc, 0xa8,
        0x5f, 0xa2, 0x64, 0x4a, 0x16, 0x85, 0x90, 0x8c, 0x98, 0xe8, 0xb5, 0x75, 0x60, 0xce, 0x0b,
        0xb5, 0x0b, 0xed, 0x92, 0x0f, 0x68, 0x1d, 0xaf, 0x8a, 0x87, 0x47, 0x00, 0xfb, 0xb7, 0x3f,
        0x97, 0x79, 0x29, 0x2a, 0x85, 0xbe, 0x8f, 0xed, 0xc5, 0xda, 0x4e, 0xd0, 0x2c, 0xa3, 0x7a,
        0x98, 0x2f, 0xfa, 0x99, 0x6d, 0x79, 0x9d, 0x1d, 0x6d, 0xd1, 0xc2, 0x48, 0x5a, 0x16, 0xaa,
        0xe0, 0x35, 0xf8, 0x22, 0x1b, 0xe7, 0x07, 0xae, 0x1b, 0x86, 0xb0, 0xc4, 0x2c, 0xed, 0x0d,
        0x9b, 0x23, 0xc3, 0xe5, 0xab, 0x72, 0x8d, 0x5e, 0xf7, 0x8b, 0x12, 0x2d, 0x6c, 0x10, 0xef,
        0x1d, 0x9b, 0x02, 0x4d, 0xa6, 0x7d, 0x37, 0x92, 0x1f, 0x46, 0xda, 0x37, 0x10, 0xec, 0x23,
        0xda, 0x05
    };
    // the path
    constexpr static std::array<uint8_t, test_vectors * depth * test_params_128::secpar_bytes> pdec_j{
        0x73, 0x46, 0x13, 0x95, 0x95, 0xc0, 0xb4, 0x1e, 0x49, 0x7b, 0xbd, 0xe3, 0x65, 0xf4, 0x2d,
        0x0a, 0xb7, 0x5b, 0x1a, 0x66, 0xb8, 0xa4, 0x21, 0x3a, 0xb3, 0xf5, 0xd7, 0x3e, 0x3b, 0xa9,
        0x8a, 0x87, 0x66, 0x80, 0x4f, 0xa3, 0xa1, 0x3a, 0x7e, 0x39, 0x1c, 0xa2, 0xcd, 0xe3, 0x7c,
        0x7c, 0x9e, 0xcf, 0x53, 0x81, 0x5c, 0x98, 0x70, 0xfa, 0xbc, 0xdc, 0xe3, 0x25, 0x1a, 0xe9,
        0xba, 0xa1, 0x0d, 0xdd, 0x73, 0x46, 0x13, 0x95, 0x95, 0xc0, 0xb4, 0x1e, 0x49, 0x7b, 0xbd,
        0xe3, 0x65, 0xf4, 0x2d, 0x0a, 0xb7, 0x5b, 0x1a, 0x66, 0xb8, 0xa4, 0x21, 0x3a, 0xb3, 0xf5,
        0xd7, 0x3e, 0x3b, 0xa9, 0x8a, 0x87, 0x66, 0x80, 0x4f, 0xa3, 0xa1, 0x3a, 0x7e, 0x39, 0x1c,
        0xa2, 0xcd, 0xe3, 0x7c, 0x7c, 0x9e, 0xcf, 0x83, 0x84, 0xe6, 0xcd, 0x73, 0x58, 0x8b, 0xb3,
        0xba, 0x12, 0x0f, 0xb0, 0x86, 0xfe, 0x4c, 0xfc, 0x73, 0x46, 0x13, 0x95, 0x95, 0xc0, 0xb4,
        0x1e, 0x49, 0x7b, 0xbd, 0xe3, 0x65, 0xf4, 0x2d, 0x0a, 0xb7, 0x5b, 0x1a, 0x66, 0xb8, 0xa4,
        0x21, 0x3a, 0xb3, 0xf5, 0xd7, 0x3e, 0x3b, 0xa9, 0x8a, 0x87, 0x7f, 0xd3, 0x3c, 0x93, 0x31,
        0x62, 0x41, 0xbe, 0x4b, 0xe3, 0x3f, 0xa2, 0x1e, 0xb6, 0x64, 0x1c, 0x81, 0x90, 0xd9, 0x7a,
        0x1e, 0xdb, 0x75, 0x95, 0x22, 0x5a, 0x77, 0x00, 0x2d, 0x04, 0xe3, 0x21, 0x73, 0x46, 0x13,
        0x95, 0x95, 0xc0, 0xb4, 0x1e, 0x49, 0x7b, 0xbd, 0xe3, 0x65, 0xf4, 0x2d, 0x0a, 0xb7, 0x5b,
        0x1a, 0x66, 0xb8, 0xa4, 0x21, 0x3a, 0xb3, 0xf5, 0xd7, 0x3e, 0x3b, 0xa9, 0x8a, 0x87, 0x7f,
        0xd3, 0x3c, 0x93, 0x31, 0x62, 0x41, 0xbe, 0x4b, 0xe3, 0x3f, 0xa2, 0x1e, 0xb6, 0x64, 0x1c,
        0xe7, 0x10, 0x19, 0xb7, 0x88, 0x81, 0x34, 0x0c, 0xbf, 0x8e, 0x82, 0x6c, 0x6e, 0xd6, 0x3b,
        0xc5,
    };
    // the hash of the leaf
    constexpr static std::array<uint8_t, test_vectors * test_params_128::secpar_bytes * 2> com_j{
      0x8c, 0xee, 0xbb, 0x29, 0xff, 0x00, 0x29, 0xd5, 0xc0, 0x47, 0xce, 0x99, 0x5d, 0xea, 0x94,
      0x79, 0x54, 0xee, 0xdf, 0xa7, 0x04, 0x3b, 0x92, 0x53, 0x00, 0x84, 0x60, 0xbf, 0x3c, 0x1c,
      0x0d, 0x15, 0x1d, 0x5c, 0x77, 0xba, 0xf7, 0xed, 0x55, 0xa1, 0xa3, 0x85, 0x2e, 0x4e, 0x78,
      0x10, 0x31, 0x28, 0x06, 0xa0, 0xfb, 0xfc, 0xf7, 0x3b, 0x91, 0x85, 0xcc, 0x80, 0x37, 0x16,
      0x38, 0x1a, 0xe0, 0x78, 0x84, 0xe4, 0xfe, 0x97, 0xe3, 0x22, 0x07, 0xe1, 0x75, 0xdb, 0x16,
      0x17, 0xb9, 0x22, 0x3b, 0x26, 0x55, 0x10, 0x28, 0x41, 0x2f, 0x6f, 0xa7, 0xfd, 0x1b, 0x36,
      0x77, 0x61, 0x7b, 0x2d, 0x79, 0x06, 0x5f, 0xbe, 0x2d, 0xfa, 0x20, 0x3f, 0x2d, 0x56, 0x3c,
      0x3e, 0x23, 0xa1, 0xec, 0xc5, 0xa4, 0xcc, 0x9d, 0x95, 0x6a, 0xc0, 0xe7, 0x97, 0xef, 0x49,
      0xe0, 0x6d, 0x10, 0x65, 0x16, 0x8c, 0x80, 0xa6
    };
};

using tv128 = tvs<test_params_128>;

template <>
struct tvs<test_params_192> {
    // test vectors from faest-ref
    constexpr static unsigned int test_vectors = 4;
    constexpr static unsigned int depth = 4;
    static_assert(depth == test_params_192::CONSTS::VEC_COM::MAX_K);

    constexpr static std::array<uint8_t, test_params_192::secpar_bytes> root_key{
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
        0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    };
    // the hashed leaves
    constexpr static std::array<uint8_t, (1 << depth) * test_params_192::secpar_bytes * 2> com{
    0x94, 0x91, 0x7d, 0x2f, 0x85, 0xf3, 0x3a, 0xf9, 0xb1, 0x9d, 0x5f, 0x34, 0xb3, 0x38, 0xad,
      0xf2, 0x8f, 0xd0, 0x31, 0xda, 0x74, 0x2d, 0x8c, 0x42, 0x81, 0x15, 0x0f, 0x42, 0x79, 0x2b,
      0x27, 0xd2, 0x65, 0x81, 0x10, 0x6b, 0x2d, 0x4d, 0xdc, 0x7f, 0x5c, 0x00, 0xde, 0x63, 0x74,
      0x0d, 0x5c, 0xc9, 0xc8, 0x37, 0x3c, 0xf2, 0x24, 0x93, 0x9b, 0x71, 0x66, 0xbe, 0x97, 0xc3,
      0xf3, 0x8e, 0x04, 0xa2, 0xe7, 0xf2, 0xa8, 0x74, 0xca, 0xe8, 0x24, 0xf5, 0x39, 0x57, 0x22,
      0xac, 0xeb, 0xd8, 0xb5, 0x17, 0x91, 0xad, 0x72, 0xff, 0x5a, 0x65, 0x5b, 0xbc, 0x77, 0x9f,
      0x63, 0x54, 0xa5, 0x16, 0x06, 0xfa, 0x4a, 0xb7, 0x41, 0xc4, 0x20, 0x57, 0x43, 0xcf, 0xb0,
      0xa6, 0xe1, 0x19, 0x4c, 0x7d, 0x08, 0xc0, 0xae, 0x8d, 0x07, 0xd8, 0x31, 0x22, 0x3d, 0x08,
      0x06, 0x2e, 0xbd, 0x63, 0x9f, 0x5d, 0x53, 0xb3, 0x9e, 0xd2, 0x0a, 0xbe, 0xcd, 0xdc, 0x12,
      0x5c, 0x47, 0x50, 0x14, 0x03, 0xac, 0xb7, 0xd6, 0x5b, 0x6b, 0x87, 0xc7, 0x4a, 0xf4, 0x14,
      0xc4, 0x64, 0x04, 0x0e, 0x9a, 0xcd, 0x92, 0xb4, 0xab, 0x7d, 0xa4, 0xff, 0x07, 0xb6, 0x83,
      0xd2, 0x00, 0xc2, 0xfc, 0x04, 0xb9, 0x5b, 0x85, 0x08, 0x71, 0x74, 0x44, 0x4e, 0x6f, 0xa6,
      0x8c, 0xfa, 0x3b, 0x2c, 0x7d, 0x25, 0xcf, 0x52, 0x76, 0x74, 0x32, 0x4e, 0x14, 0x15, 0x2a,
      0x3b, 0x64, 0x12, 0x16, 0x46, 0xdf, 0xc4, 0x53, 0xa6, 0xc8, 0x07, 0x6a, 0x99, 0x4b, 0x77,
      0x79, 0x5a, 0x02, 0xf7, 0x8f, 0xde, 0x5d, 0xed, 0x17, 0x4c, 0x97, 0xa4, 0x7b, 0xa9, 0x02,
      0xeb, 0x75, 0x39, 0x54, 0x43, 0xd2, 0x86, 0xcb, 0x21, 0x2d, 0xa4, 0xe2, 0x32, 0x41, 0xd6,
      0x50, 0xfb, 0x68, 0x69, 0xff, 0x31, 0x32, 0x04, 0x18, 0x19, 0xd0, 0xd4, 0x9b, 0x44, 0x17,
      0xa2, 0xa3, 0x40, 0xf0, 0x6a, 0x4c, 0x2e, 0xc7, 0xf4, 0x4f, 0xd4, 0x1c, 0x17, 0x16, 0xce,
      0xc1, 0xc6, 0x2e, 0xbb, 0x6f, 0xb2, 0x4f, 0xfe, 0x7f, 0xb0, 0x9a, 0x9d, 0x7b, 0xe7, 0x11,
      0xe6, 0x04, 0x79, 0x25, 0x86, 0x13, 0xf8, 0x82, 0x29, 0x34, 0xda, 0x08, 0x39, 0x9f, 0x13,
      0x86, 0x24, 0x08, 0x33, 0x2c, 0x8a, 0xbf, 0x1e, 0xfe, 0x47, 0xc3, 0x63, 0x90, 0xb5, 0xda,
      0x74, 0xcf, 0x0a, 0xe7, 0x90, 0xdd, 0xe8, 0x97, 0x4b, 0x95, 0xd4, 0xfd, 0x65, 0x09, 0x86,
      0x45, 0xa9, 0x70, 0x41, 0x1e, 0xcd, 0xce, 0xd3, 0xa2, 0xad, 0x56, 0xc8, 0xc8, 0x01, 0x3e,
      0x84, 0x41, 0x90, 0x72, 0x81, 0x92, 0x1c, 0x4d, 0x6b, 0x90, 0x8d, 0xd0, 0x83, 0x90, 0xf8,
      0xa5, 0x1f, 0x0f, 0x2e, 0xf5, 0x1b, 0xcc, 0x69, 0x03, 0x24, 0x4a, 0x83, 0xb9, 0x51, 0x0f,
      0xac, 0x37, 0xfe, 0xc3, 0xf8, 0x6d, 0xb0, 0x63, 0xf4, 0x63, 0x45, 0x46, 0x90, 0x11, 0xff,
      0xd4, 0xa7, 0xf8, 0x36, 0x9f, 0xad, 0xed, 0xbb, 0x11, 0x7f, 0xa1, 0x71, 0x5c, 0xc0, 0xdc,
      0x9b, 0xf0, 0x3d, 0xa4, 0x55, 0x44, 0xa4, 0x51, 0xc8, 0x66, 0xd5, 0x05, 0xbb, 0xbe, 0xbe,
      0x1c, 0xb6, 0x63, 0x12, 0x51, 0xba, 0x71, 0xf8, 0x06, 0x5d, 0x4a, 0x24, 0x9c, 0x6b, 0x06,
      0x97, 0xb0, 0x2b, 0xfb, 0x29, 0x00, 0xae, 0x48, 0xb6, 0x6f, 0xe6, 0xb9, 0x75, 0xf6, 0x53,
      0x5e, 0x5d, 0x65, 0x78, 0x37, 0x34, 0x7d, 0xcf, 0xc3, 0x46, 0xfd, 0xd0, 0x3d, 0x37, 0xf6,
      0xff, 0x9e, 0x9c, 0x10, 0x08, 0x9e, 0x8a, 0xa7, 0x1a, 0x60, 0x24, 0x7f, 0x4c, 0x71, 0xcd,
      0x40, 0x1b, 0xd7, 0x44, 0x33, 0xae, 0x79, 0x35, 0xe3, 0x20, 0x16, 0xd8, 0x54, 0x47, 0xb0,
      0x8e, 0x03, 0xc3, 0xd9, 0x20, 0x24, 0x93, 0xaa, 0x76, 0xc7, 0xd8, 0x2d, 0x53, 0x1e, 0xee,
      0xcb, 0xd5, 0x35, 0x7c, 0xe1, 0x7f, 0xcc, 0xc1, 0xb6, 0x96, 0x97, 0x8f, 0x04, 0xf3, 0x2a,
      0x80, 0x6c, 0xe7, 0x60, 0x7f, 0x60, 0x00, 0x76, 0x87, 0x0d, 0x13, 0x03, 0x28, 0xc4, 0xeb,
      0x09, 0xcd, 0x4d, 0x68, 0xab, 0x5f, 0x63, 0x8e, 0x3d, 0xed, 0x23, 0x48, 0x44, 0xfb, 0x21,
      0x0e, 0x73, 0xef, 0x8f, 0x3a, 0x6c, 0xe7, 0x5e, 0x92, 0x7e, 0x1e, 0xad, 0x9d, 0xe8, 0x6d,
      0x14, 0x5d, 0xf7, 0x11, 0xc4, 0x8e, 0x3f, 0xde, 0x0f, 0x31, 0x8d, 0x0a, 0x95, 0x74, 0x04,
      0x9e, 0x38, 0xb1, 0x4e, 0xcd, 0xeb, 0x82, 0x0e, 0xee, 0x4a, 0x26, 0x46, 0x51, 0xd8, 0x67,
      0x63, 0x5d, 0x3f, 0xef, 0x7d, 0x25, 0x64, 0xe2, 0x3a, 0xcf, 0x26, 0x04, 0x50, 0x9c, 0x79,
      0xcc, 0x48, 0x00, 0x4d, 0xac, 0xf7, 0x72, 0xd3, 0xc2, 0xf2, 0x55, 0x37, 0x94, 0x42, 0xa7,
      0x29, 0x6a, 0xbd, 0xf9, 0x4a, 0x20, 0x67, 0xeb, 0x78, 0xd9, 0xe7, 0x3b, 0x5b, 0x55, 0x95,
      0xc4, 0xe0, 0xbd, 0x1e, 0x3e, 0xdc, 0xb8, 0x99, 0x17, 0x56, 0x37, 0x38, 0xc7, 0xaf, 0xcc,
      0x46, 0xa6, 0x98, 0xbe, 0xda, 0x9b, 0x1a, 0x1c, 0x85, 0x03, 0x7a, 0xd1, 0x09, 0xfa, 0x33,
      0x0a, 0x90, 0x84, 0x59, 0x3a, 0x5e, 0x3e, 0xa7, 0x95, 0x03, 0x25, 0xc7, 0x83, 0x3f, 0xa5,
      0x70, 0x83, 0xa7, 0x93, 0xc3, 0x57, 0x87, 0x98, 0xb5, 0x07, 0x50, 0xd5, 0xbb, 0xf9, 0xf4,
      0x29, 0xb4, 0xa7, 0x72, 0x33, 0x36, 0x47, 0xca, 0x6a, 0x97, 0x3d, 0x94, 0x50, 0xe2, 0x2f,
      0x99, 0x36, 0x5c, 0xed, 0x75, 0x42, 0x29, 0xfd, 0x45, 0x01, 0xe2, 0x2e, 0x71, 0xf7, 0xc6,
      0x70, 0x9c, 0x7d, 0x76, 0x64, 0xf3, 0x66, 0xd6, 0xec, 0x38, 0x67, 0x2d, 0xac, 0x31, 0x7d,
      0x90, 0xfe, 0x2b, 0x1e, 0x11, 0x42, 0x31, 0x07, 0x37, 0x98, 0x0e, 0x5b, 0x63, 0x9d, 0xd6,
      0xac, 0x73, 0xca
    };
    constexpr static std::array<uint8_t, test_vectors * depth * test_params_192::secpar_bytes> pdec_j{
        0x13, 0xea, 0xec, 0xa8, 0x08, 0x62, 0x67, 0x17, 0xdb, 0x03, 0x12, 0x8b, 0xb7, 0x4d, 0x24,
        0x2c, 0x83, 0x42, 0x42, 0x26, 0xf7, 0xca, 0x25, 0xc6, 0x36, 0xb7, 0x3f, 0xe8, 0xd0, 0xe1,
        0xea, 0x75, 0x95, 0x76, 0x59, 0x17, 0x6e, 0xf6, 0x97, 0x91, 0x14, 0x3a, 0x72, 0x0c, 0x0e,
        0xc0, 0x13, 0x9b, 0x08, 0x3c, 0xba, 0xb3, 0x7b, 0x51, 0x51, 0xc9, 0x5b, 0x38, 0x82, 0xf9,
        0x8e, 0xf5, 0x96, 0x11, 0x49, 0x82, 0x81, 0x57, 0xae, 0xfe, 0x05, 0x07, 0x8a, 0x85, 0x1b,
        0x7f, 0x4e, 0xe6, 0x99, 0x42, 0x3e, 0x6c, 0xa0, 0xe2, 0x61, 0x84, 0xf9, 0xab, 0x5e, 0xc0,
        0x2b, 0x58, 0xfe, 0xb2, 0x89, 0x42, 0x13, 0xea, 0xec, 0xa8, 0x08, 0x62, 0x67, 0x17, 0xdb,
        0x03, 0x12, 0x8b, 0xb7, 0x4d, 0x24, 0x2c, 0x83, 0x42, 0x42, 0x26, 0xf7, 0xca, 0x25, 0xc6,
        0x36, 0xb7, 0x3f, 0xe8, 0xd0, 0xe1, 0xea, 0x75, 0x95, 0x76, 0x59, 0x17, 0x6e, 0xf6, 0x97,
        0x91, 0x14, 0x3a, 0x72, 0x0c, 0x0e, 0xc0, 0x13, 0x9b, 0x08, 0x3c, 0xba, 0xb3, 0x7b, 0x51,
        0x51, 0xc9, 0x5b, 0x38, 0x82, 0xf9, 0x8e, 0xf5, 0x96, 0x11, 0x49, 0x82, 0x81, 0x57, 0xae,
        0xfe, 0x05, 0x07, 0xaf, 0xfe, 0xf5, 0x5d, 0x89, 0x0d, 0x51, 0x35, 0x9a, 0x3a, 0x9f, 0x24,
        0x0a, 0xe8, 0x65, 0x64, 0xcc, 0xeb, 0x31, 0xad, 0x25, 0x67, 0x5a, 0x88, 0x13, 0xea, 0xec,
        0xa8, 0x08, 0x62, 0x67, 0x17, 0xdb, 0x03, 0x12, 0x8b, 0xb7, 0x4d, 0x24, 0x2c, 0x83, 0x42,
        0x42, 0x26, 0xf7, 0xca, 0x25, 0xc6, 0x36, 0xb7, 0x3f, 0xe8, 0xd0, 0xe1, 0xea, 0x75, 0x95,
        0x76, 0x59, 0x17, 0x6e, 0xf6, 0x97, 0x91, 0x14, 0x3a, 0x72, 0x0c, 0x0e, 0xc0, 0x13, 0x9b,
        0x25, 0x01, 0xf5, 0xee, 0x12, 0x58, 0xfa, 0xee, 0xda, 0x9f, 0xbe, 0xd5, 0xeb, 0x2d, 0xdb,
        0x94, 0x1b, 0xef, 0x20, 0x21, 0xe0, 0x1d, 0x30, 0x42, 0x36, 0xdd, 0xbe, 0xfe, 0xc8, 0xa0,
        0xb4, 0x88, 0x4d, 0x8d, 0x7d, 0x15, 0x67, 0xee, 0x8f, 0x31, 0x35, 0xf1, 0x25, 0x12, 0x04,
        0xba, 0x54, 0x17, 0x13, 0xea, 0xec, 0xa8, 0x08, 0x62, 0x67, 0x17, 0xdb, 0x03, 0x12, 0x8b,
        0xb7, 0x4d, 0x24, 0x2c, 0x83, 0x42, 0x42, 0x26, 0xf7, 0xca, 0x25, 0xc6, 0x36, 0xb7, 0x3f,
        0xe8, 0xd0, 0xe1, 0xea, 0x75, 0x95, 0x76, 0x59, 0x17, 0x6e, 0xf6, 0x97, 0x91, 0x14, 0x3a,
        0x72, 0x0c, 0x0e, 0xc0, 0x13, 0x9b, 0x25, 0x01, 0xf5, 0xee, 0x12, 0x58, 0xfa, 0xee, 0xda,
        0x9f, 0xbe, 0xd5, 0xeb, 0x2d, 0xdb, 0x94, 0x1b, 0xef, 0x20, 0x21, 0xe0, 0x1d, 0x30, 0x42,
        0x10, 0xcd, 0x70, 0x8f, 0x1f, 0x2c, 0x09, 0xfd, 0xac, 0xc1, 0x6a, 0x18, 0x32, 0x39, 0x33,
        0x14, 0x81, 0x74, 0x65, 0xbb, 0xe3, 0x48, 0x71, 0xc9,
    };
    constexpr static std::array<uint8_t, test_vectors * test_params_192::secpar_bytes * 2> com_j{
      0x94, 0x91, 0x7d, 0x2f, 0x85, 0xf3, 0x3a, 0xf9, 0xb1, 0x9d, 0x5f, 0x34, 0xb3, 0x38, 0xad,
      0xf2, 0x8f, 0xd0, 0x31, 0xda, 0x74, 0x2d, 0x8c, 0x42, 0x81, 0x15, 0x0f, 0x42, 0x79, 0x2b,
      0x27, 0xd2, 0x65, 0x81, 0x10, 0x6b, 0x2d, 0x4d, 0xdc, 0x7f, 0x5c, 0x00, 0xde, 0x63, 0x74,
      0x0d, 0x5c, 0xc9, 0xc8, 0x37, 0x3c, 0xf2, 0x24, 0x93, 0x9b, 0x71, 0x66, 0xbe, 0x97, 0xc3,
      0xf3, 0x8e, 0x04, 0xa2, 0xe7, 0xf2, 0xa8, 0x74, 0xca, 0xe8, 0x24, 0xf5, 0x39, 0x57, 0x22,
      0xac, 0xeb, 0xd8, 0xb5, 0x17, 0x91, 0xad, 0x72, 0xff, 0x5a, 0x65, 0x5b, 0xbc, 0x77, 0x9f,
      0x63, 0x54, 0xa5, 0x16, 0x06, 0xfa, 0x4a, 0xb7, 0x41, 0xc4, 0x20, 0x57, 0x43, 0xcf, 0xb0,
      0xa6, 0xe1, 0x19, 0x4c, 0x7d, 0x08, 0xc0, 0xae, 0x8d, 0x07, 0xd8, 0x31, 0x22, 0x3d, 0x08,
      0x06, 0x2e, 0xbd, 0x63, 0x9f, 0x5d, 0x53, 0xb3, 0x9e, 0xd2, 0x0a, 0xbe, 0xcd, 0xdc, 0x12,
      0x5c, 0x47, 0x50, 0x14, 0x03, 0xac, 0xb7, 0xd6, 0x5b, 0x6b, 0x87, 0xc7, 0x4a, 0xf4, 0x14,
      0xc4, 0x64, 0x04, 0x0e, 0x9a, 0xcd, 0x92, 0xb4, 0xab, 0x7d, 0xa4, 0xff, 0x07, 0xb6, 0x83,
      0xd2, 0x00, 0xc2, 0xfc, 0x04, 0xb9, 0x5b, 0x85, 0x08, 0x71, 0x74, 0x44, 0x4e, 0x6f, 0xa6,
      0x8c, 0xfa, 0x3b, 0x2c, 0x7d, 0x25, 0xcf, 0x52, 0x76, 0x74, 0x32, 0x4e,
    };
};

using tv192 = tvs<test_params_192>;


template <>
struct tvs<test_params_256> {
    // test vectors from faest-ref
    constexpr static unsigned int test_vectors = 4;
    constexpr static unsigned int depth = 5;
    static_assert(depth == test_params_256::CONSTS::VEC_COM::MAX_K);

    constexpr static std::array<uint8_t, test_params_256::secpar_bytes> root_key{
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    };
    // the hashed leaves
    constexpr static std::array<uint8_t, (1 << depth) * test_params_256::secpar_bytes * 2> com{
      0x0b, 0x87, 0xe0, 0xae, 0xef, 0x95, 0x59, 0x9f, 0x41, 0xba, 0xea, 0x5b, 0xa7, 0xba, 0xad,
      0x3a, 0xa9, 0xb1, 0x41, 0x83, 0x55, 0xc7, 0xb1, 0x99, 0x93, 0xa3, 0x28, 0x7e, 0x72, 0x1d,
      0x17, 0xcc, 0x1c, 0x99, 0xa5, 0x4a, 0x28, 0x49, 0x04, 0xaf, 0xde, 0x81, 0x15, 0xce, 0x99,
      0xaf, 0xd8, 0x3e, 0x96, 0x02, 0x69, 0x4e, 0xf4, 0x32, 0xed, 0x95, 0x7d, 0x2a, 0x6f, 0x8e,
      0x85, 0x6d, 0xbf, 0xc4, 0x17, 0xa1, 0x81, 0xda, 0x52, 0xf2, 0x2a, 0x25, 0x8e, 0x3d, 0xa5,
      0x4a, 0x81, 0x5e, 0x7a, 0x27, 0x0e, 0xee, 0x76, 0xbf, 0x17, 0xd5, 0x66, 0x90, 0x93, 0xdf,
      0xd4, 0xea, 0xef, 0x60, 0x22, 0x77, 0x9b, 0xcf, 0x8e, 0x2d, 0x2b, 0xac, 0xe8, 0xe4, 0xbe,
      0xdd, 0x8a, 0xdb, 0x21, 0x05, 0x30, 0xda, 0x6a, 0xd0, 0x7b, 0x32, 0x73, 0x11, 0x6c, 0x3d,
      0xa3, 0xb5, 0xc3, 0xa7, 0x4a, 0x80, 0xe6, 0x4e, 0x73, 0x7a, 0x4b, 0x2a, 0x78, 0xfb, 0xe9,
      0xea, 0x5f, 0x5e, 0x73, 0x47, 0xd1, 0xa2, 0xed, 0xbe, 0x50, 0xcb, 0xf0, 0x46, 0x9c, 0x78,
      0x1c, 0xd4, 0x95, 0x2e, 0x1c, 0x23, 0x0a, 0xcf, 0xf8, 0xbe, 0x94, 0xad, 0x92, 0x2e, 0x2b,
      0x8e, 0x6e, 0xe1, 0x92, 0xba, 0xba, 0x93, 0x9e, 0x2e, 0x26, 0x08, 0xd2, 0xc1, 0x00, 0x06,
      0x9c, 0x70, 0x87, 0x6d, 0x18, 0x03, 0x78, 0x28, 0x7e, 0x85, 0x8a, 0x29, 0x54, 0x8d, 0x7c,
      0xf9, 0x88, 0x84, 0x27, 0xaf, 0x97, 0x15, 0xd4, 0x95, 0xe8, 0xcb, 0x28, 0x2d, 0xb1, 0x7f,
      0x85, 0x66, 0x09, 0xb2, 0x34, 0x51, 0xf1, 0xf3, 0x30, 0x38, 0x27, 0x33, 0xc2, 0xf8, 0x2a,
      0x1a, 0xe8, 0x34, 0x7e, 0xbb, 0x9b, 0x3a, 0x6c, 0xb3, 0x60, 0xf8, 0xc9, 0xf4, 0x47, 0x72,
      0x12, 0xec, 0xd1, 0xfe, 0x00, 0xc1, 0xac, 0x09, 0x75, 0x0e, 0x11, 0xc8, 0xf3, 0x0f, 0xd8,
      0x62, 0xda, 0x48, 0x7c, 0x87, 0xcf, 0xf0, 0xd0, 0xbf, 0x4e, 0xd0, 0x20, 0xc6, 0xdb, 0xac,
      0x85, 0x84, 0xe3, 0x35, 0x04, 0x4c, 0xd3, 0xc4, 0xdc, 0xc2, 0x45, 0xf5, 0x33, 0x2a, 0x30,
      0x76, 0x47, 0x01, 0xbd, 0xf8, 0x8a, 0x00, 0x3b, 0xa3, 0x6d, 0xe6, 0x45, 0x82, 0x79, 0xdf,
      0x38, 0xfe, 0x71, 0x00, 0xa9, 0x39, 0x6b, 0xf6, 0xd4, 0x54, 0xd2, 0x2b, 0xf8, 0x8c, 0xf8,
      0xcd, 0xfc, 0xdc, 0xdf, 0x93, 0x23, 0xa3, 0x28, 0x4e, 0x31, 0x21, 0x91, 0xca, 0xff, 0xe4,
      0x39, 0xdf, 0xe7, 0x2b, 0xa3, 0xe7, 0x33, 0x8d, 0x09, 0xf8, 0x9b, 0x0c, 0xf6, 0x8f, 0x96,
      0xdd, 0x93, 0x1f, 0x88, 0xb7, 0xde, 0x0d, 0x32, 0x17, 0xc6, 0x64, 0x55, 0x30, 0xd9, 0x1f,
      0x16, 0xdd, 0x3c, 0x25, 0xb1, 0x55, 0xa8, 0xb0, 0xb1, 0x06, 0x7a, 0x4a, 0xa6, 0xe1, 0x35,
      0x1c, 0x3a, 0x8d, 0x03, 0x48, 0x7b, 0xfb, 0xfb, 0xa4, 0x58, 0xcb, 0xbc, 0x67, 0x70, 0x30,
      0xbf, 0x67, 0xae, 0xfd, 0x37, 0x85, 0x33, 0xad, 0xf4, 0x2e, 0x01, 0x51, 0x69, 0x6f, 0xc9,
      0x51, 0xad, 0x8e, 0xe6, 0x22, 0x9c, 0x59, 0xd7, 0x39, 0xc5, 0x18, 0xaa, 0xd9, 0x06, 0xe1,
      0x99, 0x88, 0xc3, 0x49, 0x3b, 0x92, 0x55, 0x7c, 0x30, 0x22, 0x63, 0xd7, 0x1f, 0x42, 0x2b,
      0xa2, 0x77, 0x20, 0x72, 0x31, 0x2d, 0xff, 0xd4, 0xdc, 0x5d, 0x2b, 0xda, 0x82, 0xdb, 0xeb,
      0x6f, 0x97, 0x58, 0x42, 0x6b, 0x11, 0xfa, 0x13, 0x7d, 0x81, 0x87, 0xbc, 0x8e, 0x57, 0xf4,
      0xa4, 0xe0, 0x95, 0xa7, 0x34, 0xd0, 0x6c, 0x54, 0x9b, 0x91, 0x56, 0x7f, 0xcb, 0x30, 0xfc,
      0x35, 0x58, 0xd5, 0x13, 0x3a, 0x1c, 0xee, 0xaa, 0x68, 0x33, 0xbf, 0xb0, 0x79, 0x21, 0x6c,
      0x64, 0x07, 0x3f, 0x7e, 0xb3, 0x1e, 0x1f, 0x56, 0xf2, 0x7a, 0xa1, 0xaa, 0x14, 0x04, 0x3a,
      0x3b, 0xd4, 0x36, 0xdf, 0xde, 0xfa, 0x2e, 0x14, 0xba, 0x33, 0x26, 0xa5, 0xc3, 0xa5, 0xe6,
      0xd8, 0xcc, 0xdd, 0x95, 0x28, 0xc6, 0xb9, 0x10, 0x91, 0x38, 0xb0, 0xe5, 0xc6, 0xe0, 0x58,
      0x6d, 0xa0, 0xf3, 0x32, 0x0a, 0xa1, 0x8c, 0xaa, 0xb7, 0xf3, 0x07, 0xf0, 0x8e, 0xda, 0x00,
      0x37, 0x72, 0x30, 0x42, 0x4a, 0x4c, 0x22, 0x2f, 0xd6, 0xc9, 0xe9, 0x7d, 0xc7, 0x81, 0xd2,
      0x22, 0xbd, 0x49, 0x31, 0x75, 0x44, 0x9f, 0x98, 0x12, 0x6c, 0x12, 0x5c, 0x0e, 0x3e, 0xa2,
      0xaa, 0x85, 0xd1, 0x94, 0x15, 0x26, 0x4b, 0x20, 0x48, 0x73, 0x0e, 0xa0, 0x43, 0x7d, 0x3b,
      0x67, 0xeb, 0x6a, 0x96, 0x90, 0xd1, 0x02, 0xa4, 0xb5, 0x85, 0x87, 0x10, 0xe1, 0x60, 0x60,
      0x8e, 0xf1, 0xf8, 0x9b, 0xd8, 0x14, 0x13, 0xcf, 0x6c, 0x01, 0x6c, 0xeb, 0x6d, 0xcf, 0x61,
      0xb6, 0xd4, 0x83, 0xaa, 0xb4, 0x1a, 0x7b, 0xee, 0xd3, 0x7a, 0xf6, 0x55, 0x6a, 0xa7, 0x06,
      0x4c, 0x17, 0xe5, 0x94, 0x39, 0xfe, 0xb6, 0xb3, 0xd9, 0xa5, 0x06, 0x19, 0x10, 0xeb, 0x8a,
      0xa4, 0xe8, 0xdc, 0x2d, 0x9d, 0x80, 0xf2, 0x9c, 0x3f, 0x83, 0x06, 0x34, 0xe9, 0xb1, 0xfa,
      0xe5, 0x0c, 0xa0, 0xc4, 0x71, 0x78, 0xa2, 0xbf, 0x77, 0xc9, 0xc4, 0x7e, 0x38, 0x53, 0xba,
      0x03, 0x38, 0x5b, 0x85, 0x28, 0x3d, 0xaa, 0x2a, 0x09, 0x5d, 0xf5, 0x29, 0x29, 0x98, 0x57,
      0x2c, 0xb5, 0x88, 0x77, 0xaf, 0x94, 0x15, 0x05, 0x21, 0x3b, 0xee, 0x00, 0xe8, 0x8b, 0x2d,
      0xfa, 0xa0, 0x13, 0x04, 0x5c, 0xd5, 0xe2, 0xc3, 0x78, 0xa3, 0x0e, 0x7f, 0x6a, 0x2c, 0x0f,
      0x63, 0x04, 0x35, 0x3d, 0x03, 0xc2, 0x62, 0x1d, 0x52, 0xd8, 0x89, 0x9d, 0x4d, 0x6e, 0x34,
      0x7b, 0xb2, 0xfe, 0xdb, 0x7d, 0x7d, 0x6c, 0x37, 0xf9, 0xde, 0x14, 0xcf, 0xfc, 0x15, 0xe8,
      0x56, 0x92, 0x03, 0xad, 0xe8, 0x23, 0xe9, 0xd8, 0xd4, 0x7b, 0x74, 0x08, 0x67, 0xbe, 0x5a,
      0x94, 0xeb, 0x8f, 0xab, 0x04, 0xe4, 0x81, 0x26, 0xdc, 0xa4, 0xb8, 0x02, 0xde, 0x3e, 0xe3,
      0xd9, 0x6e, 0x61, 0x58, 0xb3, 0xf0, 0x06, 0x77, 0xcc, 0x00, 0x6d, 0xfd, 0xcf, 0x71, 0x91,
      0x19, 0x78, 0x4a, 0x22, 0x40, 0xa0, 0x1d, 0x49, 0x86, 0x3e, 0xdd, 0x83, 0x8b, 0x24, 0xec,
      0x46, 0x8b, 0x16, 0xcd, 0xf3, 0xb5, 0x1a, 0x60, 0x73, 0xd7, 0x5a, 0xc2, 0xdc, 0x2b, 0x3f,
      0x30, 0x60, 0x31, 0x28, 0xce, 0x1d, 0x4b, 0xbc, 0x0f, 0x04, 0xf8, 0xef, 0x8d, 0x52, 0x5a,
      0x3f, 0xc9, 0x35, 0xf4, 0xc1, 0x83, 0xac, 0xfa, 0x66, 0xd9, 0x39, 0xbd, 0x84, 0x27, 0x2f,
      0xd7, 0xe3, 0x38, 0x4c, 0xd3, 0x68, 0xc1, 0xbc, 0x31, 0x20, 0x7d, 0x60, 0x68, 0x6e, 0x6d,
      0x6b, 0x18, 0x76, 0xbe, 0xd6, 0xbe, 0x4f, 0xa7, 0x52, 0x6a, 0xda, 0xec, 0x58, 0xf5, 0xdb,
      0x4f, 0xc0, 0xf3, 0xb2, 0xb0, 0xa7, 0x2f, 0x3a, 0x25, 0x0f, 0xbc, 0x8f, 0xc0, 0x55, 0xf1,
      0x49, 0xa6, 0x62, 0x0e, 0x50, 0x94, 0x34, 0x66, 0x52, 0xc8, 0xab, 0x18, 0x0a, 0xf0, 0xcd,
      0x43, 0x59, 0x36, 0x9f, 0xfd, 0xa1, 0x46, 0xda, 0xfd, 0x70, 0x6f, 0xc1, 0x11, 0xf7, 0x72,
      0xb1, 0x95, 0x05, 0x20, 0xfa, 0xe2, 0xd1, 0x6b, 0x06, 0x66, 0x05, 0x34, 0xe1, 0xd6, 0x30,
      0x1c, 0x9d, 0xd2, 0x38, 0x07, 0x15, 0x98, 0x4d, 0x4c, 0x61, 0x15, 0x1c, 0x68, 0x1d, 0x4a,
      0x7a, 0x3f, 0x36, 0x60, 0x34, 0x52, 0x17, 0x6a, 0x87, 0xc3, 0x01, 0x24, 0xe8, 0x31, 0x58,
      0x24, 0x9e, 0x5e, 0x86, 0x92, 0xa0, 0x8f, 0x3a, 0xd4, 0xac, 0x2d, 0xff, 0xeb, 0x51, 0xa0,
      0xf6, 0xd9, 0x48, 0x4f, 0x5f, 0xf2, 0xa3, 0x20, 0x71, 0xaa, 0x31, 0x59, 0xc6, 0x95, 0x85,
      0xce, 0x26, 0x06, 0x8d, 0x0f, 0x4e, 0xeb, 0xc5, 0x15, 0xa3, 0x62, 0x06, 0x01, 0xe3, 0x3b,
      0x73, 0xab, 0x28, 0x58, 0x67, 0x59, 0xcf, 0x93, 0xd7, 0xb8, 0x36, 0x36, 0xf7, 0x85, 0x09,
      0x67, 0xd4, 0x4e, 0x39, 0xd1, 0x35, 0xec, 0x4e, 0xae, 0x42, 0xa8, 0xef, 0x2c, 0xc1, 0xe9,
      0x58, 0xdb, 0x0d, 0x3f, 0x5b, 0x78, 0x33, 0x57, 0x51, 0xe0, 0xf3, 0x33, 0xc0, 0x31, 0xcf,
      0x3b, 0x43, 0x6d, 0xdd, 0x29, 0x31, 0x7e, 0xb3, 0xb2, 0x6d, 0x44, 0x9b, 0x1e, 0x39, 0x5e,
      0x87, 0xf8, 0x58, 0x93, 0x74, 0xb5, 0x9f, 0x3b, 0xf3, 0xbe, 0x91, 0x46, 0x18, 0x20, 0x1b,
      0x6c, 0xa9, 0x9b, 0x53, 0xf2, 0xbd, 0xe6, 0xb4, 0x02, 0xc4, 0x96, 0x56, 0x03, 0x52, 0x1f,
      0x77, 0x86, 0xe5, 0x1d, 0x5c, 0x3d, 0x87, 0x3c, 0x0f, 0xe1, 0x5c, 0xad, 0xc7, 0x49, 0xb8,
      0x73, 0x74, 0x26, 0x14, 0x09, 0x40, 0x28, 0xf1, 0x63, 0xa0, 0x83, 0x16, 0xae, 0xfc, 0xdf,
      0x47, 0x36, 0x87, 0x34, 0x88, 0x5a, 0xc1, 0x17, 0x5c, 0xce, 0xa3, 0xef, 0x47, 0x50, 0xdc,
      0x26, 0x4b, 0xaa, 0x01, 0x1f, 0x63, 0xb9, 0xfe, 0x13, 0x4b, 0xfd, 0x7c, 0x95, 0x04, 0x95,
      0x47, 0x6e, 0xea, 0x9b, 0x8c, 0xfa, 0x8c, 0x6c, 0x33, 0x8c, 0x9f, 0xae, 0xea, 0xe6, 0x8a,
      0x6a, 0x2f, 0x25, 0x50, 0x75, 0x95, 0x35, 0x4c, 0xbd, 0x71, 0xd9, 0x83, 0x20, 0xaa, 0x9b,
      0x69, 0x09, 0xc9, 0xf3, 0x19, 0x7f, 0x6f, 0xb4, 0xbc, 0xad, 0x90, 0x96, 0x95, 0xd2, 0x60,
      0x5f, 0x81, 0xf7, 0xd6, 0x38, 0x7d, 0x2b, 0x03, 0x82, 0xc5, 0xd2, 0x4f, 0xfb, 0x79, 0x92,
      0x6c, 0x63, 0x54, 0x65, 0x67, 0x73, 0xc1, 0x39, 0x82, 0x77, 0x8c, 0x2a, 0xe1, 0xcc, 0x7f,
      0x79, 0x39, 0xb2, 0x49, 0x75, 0x23, 0xfd, 0x46, 0xe9, 0x93, 0xd3, 0x4c, 0x68, 0xdb, 0x1f,
      0x02, 0x9c, 0x1b, 0xc4, 0x79, 0x66, 0x83, 0xd3, 0xea, 0xc9, 0x6b, 0xcb, 0x6b, 0x21, 0xe9,
      0xba, 0xd1, 0x73, 0x2a, 0xa4, 0x8d, 0x00, 0x97, 0xb7, 0xcc, 0x3e, 0xa9, 0x80, 0xf8, 0x40,
      0x83, 0x5b, 0x28, 0xb2, 0x2a, 0xac, 0xf3, 0x90, 0x69, 0x60, 0x3f, 0x62, 0x65, 0x4f, 0x37,
      0x97, 0xc6, 0xcf, 0x19, 0xdc, 0x48, 0xe1, 0xdd, 0xcb, 0x8a, 0x2f, 0x18, 0x75, 0xbf, 0xe7,
      0xa5, 0xe6, 0x8c, 0x9a, 0x48, 0xca, 0x77, 0xce, 0x0e, 0x57, 0x0e, 0x84, 0x93, 0xa2, 0x65,
      0x6b, 0xa2, 0x99, 0x87, 0xbf, 0x8c, 0x9f, 0x35, 0x25, 0x74, 0x9b, 0x44, 0xf9, 0xa7, 0x5b,
      0x6d, 0xea, 0x99, 0x8f, 0x65, 0x65, 0xae, 0x28, 0x21, 0xfc, 0x59, 0x43, 0x82, 0x39, 0xd7,
      0xeb, 0x4b, 0xfc, 0x01, 0x49, 0xa2, 0xbc, 0x64, 0x83, 0x1c, 0x24, 0xd6, 0xa5, 0x60, 0x5a,
      0xcb, 0x0a, 0x15, 0x35, 0xaf, 0xa9, 0xaf, 0xd6, 0x46, 0x41, 0xd4, 0xc2, 0x78, 0x62, 0x86,
      0x44, 0xd9, 0x79, 0x8d, 0x04, 0x0e, 0x24, 0x76, 0x4c, 0xce, 0xff, 0x99, 0x11, 0xbb, 0xdc,
      0x0c, 0x61, 0x81, 0x3d, 0x1d, 0xeb, 0x17, 0xca, 0x64, 0x15, 0x59, 0xa0, 0x2b, 0xb0, 0xbb,
      0x8f, 0x25, 0x23, 0xc2, 0xc5, 0x4a, 0x5b, 0xf0, 0x7c, 0x4f, 0x28, 0x8d, 0x50, 0x6f, 0xe6,
      0xde, 0x36, 0xe8, 0x4d, 0xa0, 0x71, 0xd1, 0x1c, 0x43, 0xb6, 0x14, 0xef, 0xdc, 0xf5, 0xab,
      0xbd, 0xfa, 0x1c, 0x0e, 0x26, 0xd9, 0x36, 0x89, 0xa8, 0x7f, 0x83, 0x24, 0x58, 0xa7, 0x26,
      0x13, 0xc6, 0x7d, 0xcb, 0x9e, 0x4c, 0x61, 0xfb, 0x6a, 0xa6, 0x1b, 0x32, 0x63, 0xe8, 0x5c,
      0xa1, 0x9c, 0x97, 0xbe, 0x71, 0x73, 0xdb, 0x90, 0x18, 0x30, 0x45, 0xe6, 0xcf, 0x4b, 0xd6,
      0x58, 0x40, 0x5d, 0x3f, 0xa6, 0x2f, 0xb8, 0x83, 0xac, 0xe5, 0xdb, 0x79, 0x1d, 0x49, 0xdf,
      0x7c, 0x81, 0x0d, 0x0e, 0x79, 0xb0, 0x8d, 0xf5, 0xfe, 0x05, 0x65, 0x53, 0xa5, 0xb9, 0xff,
      0x4f, 0x0b, 0x20, 0x3d, 0x61, 0x2f, 0xa8, 0x1c, 0xff, 0x40, 0xd2, 0x15, 0xbc, 0x9e, 0x84,
      0x8b, 0xab, 0x90, 0x99, 0xa2, 0x1f, 0xdb, 0x41, 0x94, 0xba, 0xb0, 0x02, 0xb7, 0xdb, 0x3e,
      0xc0, 0xca, 0x63, 0x36, 0xa0, 0x65, 0x55, 0x3f, 0x9c, 0x8f, 0xd0, 0x37, 0x7b, 0x86, 0xa2,
      0x6d, 0x4b, 0x79, 0x35, 0xab, 0x4e, 0xf4, 0x8e, 0xaf, 0x57, 0x3d, 0x67, 0xee, 0xd4, 0x12,
      0x46, 0x7e, 0x90, 0x57, 0x37, 0x65, 0xc7, 0xaf, 0xf7, 0x44, 0x0a, 0xd4, 0x46, 0x4b, 0x4c,
      0x86, 0x17, 0xfe, 0x8d, 0x86, 0x1c, 0xea, 0xbb, 0x7b, 0x36, 0xea, 0xb3, 0x64, 0x34, 0x70,
      0x53, 0x13, 0xa5, 0x28, 0x72, 0x45, 0x9b, 0x67, 0x43, 0xe9, 0x91, 0x95, 0xba, 0xdd, 0xb9,
      0xb6, 0x00, 0xf8, 0xf6, 0xa5, 0x7f, 0xce, 0x98, 0x35, 0xe9, 0xb0, 0xd8, 0x6d, 0xf8, 0x31,
      0x55, 0xe9, 0x18, 0x12, 0xbc, 0xd2, 0xa7, 0x7c, 0x55, 0x41, 0x60, 0x9e, 0x91, 0x05, 0xf1,
      0x5a, 0xaa, 0x46, 0xbd, 0xda, 0x69, 0xd9, 0xdb, 0xdc, 0xe8, 0xb3, 0x17, 0x0d, 0x76, 0x54,
      0x39, 0x27, 0x59, 0x0b, 0x94, 0xcd, 0xbb, 0x3a, 0xff, 0x48, 0x9b, 0x2c, 0x98, 0x40, 0x78,
      0xea, 0xfa, 0x3b, 0x63, 0x92, 0xfd, 0x3a, 0x67, 0xdd, 0x1e, 0xe7, 0xca, 0xfd, 0x5a, 0x86,
      0x14, 0x2c, 0xac, 0x64, 0x90, 0x40, 0xec, 0x6a, 0xa3, 0x5d, 0x0f, 0x28, 0x97, 0xfc, 0xf6,
      0x51, 0xfa, 0x8b, 0xa0, 0x30, 0x19, 0x72, 0x33, 0x8d, 0x35, 0xa3, 0x41, 0x17, 0xab, 0xa4,
      0x0b, 0x5f, 0xa7, 0xbf, 0x16, 0x06, 0x66, 0xb6, 0xf8, 0x42, 0x03, 0x38, 0xf2, 0x4d, 0x01,
      0x64, 0x2e, 0xec, 0x23, 0x60, 0x71, 0x27, 0x27, 0x49, 0xc9, 0x3a, 0x42, 0x7f, 0x09, 0xb1,
      0x0d, 0xa6, 0x68, 0xb9, 0xe8, 0x05, 0xd6, 0x80, 0xdb, 0xa6, 0x74, 0x24, 0x05, 0x0f, 0x9e,
      0xfe, 0x07, 0xbc, 0x64, 0x93, 0xf2, 0xd7, 0x7f, 0x66, 0x4f, 0x49, 0x42, 0x81, 0x90, 0xf5,
      0xef, 0xa3, 0xe6, 0xf3, 0x6c, 0xd8, 0x83, 0x82, 0x5d, 0x8c, 0x15, 0xd8, 0x0e, 0x92, 0x89,
      0x0d, 0x45, 0x4d, 0x22, 0xf5, 0xcf, 0xea, 0x5d, 0xbe, 0xcd, 0xfa, 0x35, 0x6a, 0xb9, 0xc6,
      0xaf, 0x91, 0xb6, 0x3d, 0x27, 0x2d, 0xa2, 0x67, 0xc9, 0xaa, 0x33, 0x22, 0x1f, 0xcc, 0xbd,
      0x63, 0xf8, 0x59, 0xaa, 0xd7, 0xaf, 0x6a, 0x9b, 0x86, 0xc9, 0x8b, 0x54, 0x8d, 0x22, 0x6b,
      0x72, 0x67, 0x76, 0x68, 0xf8, 0x8e, 0xa9, 0x86, 0x46, 0xc3, 0x5e, 0x7a, 0x5d, 0x43, 0x27,
      0xa8, 0x74, 0x6e, 0x7e, 0x6e, 0xf7, 0xb0, 0x0c, 0xbf, 0x68, 0xe2, 0xa4, 0x6e, 0xdd, 0xfe,
      0x24, 0x6d, 0x91, 0x06, 0x3b, 0xf9, 0x98, 0x19, 0xdd, 0x5b, 0xca, 0x5d, 0x5a, 0xa4, 0xe4,
      0x90, 0xb8, 0x9f, 0x08, 0x1c, 0xbb, 0x44, 0x78, 0x12, 0xae, 0x4e, 0x3d, 0x3e, 0x3e, 0xad,
      0xa6, 0x51, 0x84, 0xf3, 0x1a, 0x21, 0xf8, 0x27, 0xd4, 0xad, 0x9b, 0x49, 0xa8, 0x93, 0xc7,
      0x92, 0x2e, 0xfd, 0xb0, 0x84, 0x7d, 0x0b, 0xbf, 0x6a, 0xa7, 0x19, 0x5a, 0x2c, 0xac, 0x87,
      0xac, 0x75, 0x74, 0x64, 0x3b, 0xea, 0x01, 0x45, 0x10, 0x94, 0xc3, 0xcf, 0x38, 0xa9, 0x8b,
      0x19, 0xc0, 0x44, 0xfe, 0x60, 0x14, 0x8e, 0x7d, 0x94, 0x00, 0x95, 0x6f, 0x1c, 0x6d, 0x77,
      0xcf, 0xe9, 0x8c, 0xde, 0x0c, 0xbc, 0x93, 0x85, 0xc4, 0xa9, 0x46, 0x7d, 0x2c, 0xa7, 0x7e,
      0xf5, 0x5e, 0x8c, 0x1e, 0xc8, 0x68, 0x02, 0xe6, 0x35, 0x31, 0x11, 0x17, 0x3b, 0x0b, 0x55,
      0x3d, 0xea, 0x89, 0x0d, 0x2e, 0x6e, 0x60, 0xa9, 0x13, 0x31, 0x43, 0x05, 0x30, 0xb4, 0x0a,
      0x63, 0xf6, 0x00, 0xe2, 0x0a, 0xf1, 0xc3, 0x25
    };
    constexpr static std::array<uint8_t, test_vectors * depth * test_params_256::secpar_bytes> pdec_j{
        0x0e, 0xbc, 0xb5, 0xde, 0xb5, 0x2c, 0x83, 0xbd, 0x08, 0xa8, 0xa9, 0x35, 0x18, 0x2c, 0x91,
        0x99, 0xd2, 0x43, 0x56, 0x53, 0x28, 0x81, 0x60, 0x2f, 0x80, 0x9e, 0xb3, 0x83, 0xc5, 0xff,
        0x5d, 0x56, 0x97, 0x20, 0xe4, 0x05, 0x16, 0x40, 0x7d, 0x2c, 0x24, 0x9a, 0x9b, 0x75, 0x6a,
        0x46, 0xf7, 0x1a, 0x80, 0xde, 0x90, 0x97, 0x11, 0xcf, 0xa3, 0x0b, 0xcd, 0x15, 0x1f, 0xce,
        0x14, 0x4c, 0x5d, 0x56, 0x2d, 0x67, 0xc6, 0x55, 0x70, 0x4e, 0x03, 0x51, 0xa1, 0xaa, 0xa2,
        0x39, 0x84, 0x0d, 0x11, 0x8d, 0xa6, 0x92, 0x77, 0x4c, 0x01, 0x73, 0xfa, 0x2d, 0xa1, 0x54,
        0xa9, 0xca, 0x06, 0xe7, 0xfd, 0x53, 0xb1, 0xef, 0x89, 0x3e, 0xe8, 0x4d, 0x11, 0xa7, 0x1e,
        0x32, 0xf9, 0xe8, 0x0b, 0x10, 0xae, 0x48, 0xee, 0x5d, 0x03, 0x9e, 0x90, 0xf0, 0x26, 0x3a,
        0xf7, 0x88, 0xf8, 0xbb, 0x21, 0x00, 0x57, 0x20, 0x25, 0xa7, 0x1d, 0xe0, 0xad, 0xac, 0x15,
        0x9e, 0x48, 0xfc, 0xbd, 0xb3, 0x72, 0xfc, 0xa3, 0x14, 0x1c, 0xba, 0x1e, 0xe7, 0x8a, 0x57,
        0xb5, 0x62, 0xce, 0xd2, 0x27, 0xaf, 0x0e, 0xa6, 0x86, 0xd1, 0x0e, 0xbc, 0xb5, 0xde, 0xb5,
        0x2c, 0x83, 0xbd, 0x08, 0xa8, 0xa9, 0x35, 0x18, 0x2c, 0x91, 0x99, 0xd2, 0x43, 0x56, 0x53,
        0x28, 0x81, 0x60, 0x2f, 0x80, 0x9e, 0xb3, 0x83, 0xc5, 0xff, 0x5d, 0x56, 0x97, 0x20, 0xe4,
        0x05, 0x16, 0x40, 0x7d, 0x2c, 0x24, 0x9a, 0x9b, 0x75, 0x6a, 0x46, 0xf7, 0x1a, 0x80, 0xde,
        0x90, 0x97, 0x11, 0xcf, 0xa3, 0x0b, 0xcd, 0x15, 0x1f, 0xce, 0x14, 0x4c, 0x5d, 0x56, 0x2d,
        0x67, 0xc6, 0x55, 0x70, 0x4e, 0x03, 0x51, 0xa1, 0xaa, 0xa2, 0x39, 0x84, 0x0d, 0x11, 0x8d,
        0xa6, 0x92, 0x77, 0x4c, 0x01, 0x73, 0xfa, 0x2d, 0xa1, 0x54, 0xa9, 0xca, 0x06, 0xe7, 0xfd,
        0x53, 0xb1, 0xef, 0x89, 0x3e, 0xe8, 0x4d, 0x11, 0xa7, 0x1e, 0x32, 0xf9, 0xe8, 0x0b, 0x10,
        0xae, 0x48, 0xee, 0x5d, 0x03, 0x9e, 0x90, 0xf0, 0x26, 0x3a, 0xf7, 0x88, 0xf8, 0xbb, 0x21,
        0x00, 0x57, 0x20, 0x2c, 0x81, 0x36, 0x09, 0xc1, 0xad, 0x8a, 0x5f, 0xfb, 0x98, 0xa2, 0x57,
        0x43, 0x42, 0xe1, 0x5a, 0x8f, 0xfd, 0x4d, 0x94, 0x18, 0x3d, 0xce, 0x6b, 0xc3, 0xed, 0xd4,
        0x8b, 0x35, 0x25, 0xa2, 0x6a, 0x0e, 0xbc, 0xb5, 0xde, 0xb5, 0x2c, 0x83, 0xbd, 0x08, 0xa8,
        0xa9, 0x35, 0x18, 0x2c, 0x91, 0x99, 0xd2, 0x43, 0x56, 0x53, 0x28, 0x81, 0x60, 0x2f, 0x80,
        0x9e, 0xb3, 0x83, 0xc5, 0xff, 0x5d, 0x56, 0x97, 0x20, 0xe4, 0x05, 0x16, 0x40, 0x7d, 0x2c,
        0x24, 0x9a, 0x9b, 0x75, 0x6a, 0x46, 0xf7, 0x1a, 0x80, 0xde, 0x90, 0x97, 0x11, 0xcf, 0xa3,
        0x0b, 0xcd, 0x15, 0x1f, 0xce, 0x14, 0x4c, 0x5d, 0x56, 0x2d, 0x67, 0xc6, 0x55, 0x70, 0x4e,
        0x03, 0x51, 0xa1, 0xaa, 0xa2, 0x39, 0x84, 0x0d, 0x11, 0x8d, 0xa6, 0x92, 0x77, 0x4c, 0x01,
        0x73, 0xfa, 0x2d, 0xa1, 0x54, 0xa9, 0xca, 0x06, 0xe7, 0xfd, 0x53, 0x4b, 0x26, 0x31, 0x94,
        0x1b, 0x2d, 0x28, 0x72, 0xbe, 0xea, 0x0f, 0x55, 0x86, 0xfa, 0x76, 0x12, 0x25, 0x42, 0xa6,
        0xc0, 0xb4, 0xfd, 0x0a, 0xee, 0xef, 0x49, 0x49, 0xa4, 0xb0, 0x6a, 0x9e, 0x4a, 0xbc, 0x0e,
        0xfd, 0xb0, 0x0f, 0x7b, 0xa4, 0x12, 0xc6, 0x72, 0xc7, 0xa2, 0x8a, 0x6e, 0x82, 0x44, 0xf5,
        0xc4, 0x82, 0xfd, 0x34, 0x61, 0x5c, 0xdd, 0xf1, 0xfb, 0xcd, 0x9d, 0x49, 0x8e, 0x59, 0xde,
        0x0e, 0xbc, 0xb5, 0xde, 0xb5, 0x2c, 0x83, 0xbd, 0x08, 0xa8, 0xa9, 0x35, 0x18, 0x2c, 0x91,
        0x99, 0xd2, 0x43, 0x56, 0x53, 0x28, 0x81, 0x60, 0x2f, 0x80, 0x9e, 0xb3, 0x83, 0xc5, 0xff,
        0x5d, 0x56, 0x97, 0x20, 0xe4, 0x05, 0x16, 0x40, 0x7d, 0x2c, 0x24, 0x9a, 0x9b, 0x75, 0x6a,
        0x46, 0xf7, 0x1a, 0x80, 0xde, 0x90, 0x97, 0x11, 0xcf, 0xa3, 0x0b, 0xcd, 0x15, 0x1f, 0xce,
        0x14, 0x4c, 0x5d, 0x56, 0x2d, 0x67, 0xc6, 0x55, 0x70, 0x4e, 0x03, 0x51, 0xa1, 0xaa, 0xa2,
        0x39, 0x84, 0x0d, 0x11, 0x8d, 0xa6, 0x92, 0x77, 0x4c, 0x01, 0x73, 0xfa, 0x2d, 0xa1, 0x54,
        0xa9, 0xca, 0x06, 0xe7, 0xfd, 0x53, 0x4b, 0x26, 0x31, 0x94, 0x1b, 0x2d, 0x28, 0x72, 0xbe,
        0xea, 0x0f, 0x55, 0x86, 0xfa, 0x76, 0x12, 0x25, 0x42, 0xa6, 0xc0, 0xb4, 0xfd, 0x0a, 0xee,
        0xef, 0x49, 0x49, 0xa4, 0xb0, 0x6a, 0x9e, 0x4a, 0x9a, 0x1b, 0x79, 0x51, 0x28, 0x6b, 0x40,
        0x61, 0xc2, 0x70, 0x7b, 0x80, 0x73, 0x42, 0x99, 0xa7, 0x41, 0x93, 0x04, 0x1b, 0x3c, 0x32,
        0x39, 0x7d, 0x22, 0x4e, 0x7b, 0xc0, 0x76, 0x18, 0x64, 0xbd,
    };
    constexpr static std::array<uint8_t, test_vectors * test_params_256::secpar_bytes * 2> com_j{
      0x0b, 0x87, 0xe0, 0xae, 0xef, 0x95, 0x59, 0x9f, 0x41, 0xba, 0xea, 0x5b, 0xa7, 0xba, 0xad,
      0x3a, 0xa9, 0xb1, 0x41, 0x83, 0x55, 0xc7, 0xb1, 0x99, 0x93, 0xa3, 0x28, 0x7e, 0x72, 0x1d,
      0x17, 0xcc, 0x1c, 0x99, 0xa5, 0x4a, 0x28, 0x49, 0x04, 0xaf, 0xde, 0x81, 0x15, 0xce, 0x99,
      0xaf, 0xd8, 0x3e, 0x96, 0x02, 0x69, 0x4e, 0xf4, 0x32, 0xed, 0x95, 0x7d, 0x2a, 0x6f, 0x8e,
      0x85, 0x6d, 0xbf, 0xc4, 0x17, 0xa1, 0x81, 0xda, 0x52, 0xf2, 0x2a, 0x25, 0x8e, 0x3d, 0xa5,
      0x4a, 0x81, 0x5e, 0x7a, 0x27, 0x0e, 0xee, 0x76, 0xbf, 0x17, 0xd5, 0x66, 0x90, 0x93, 0xdf,
      0xd4, 0xea, 0xef, 0x60, 0x22, 0x77, 0x9b, 0xcf, 0x8e, 0x2d, 0x2b, 0xac, 0xe8, 0xe4, 0xbe,
      0xdd, 0x8a, 0xdb, 0x21, 0x05, 0x30, 0xda, 0x6a, 0xd0, 0x7b, 0x32, 0x73, 0x11, 0x6c, 0x3d,
      0xa3, 0xb5, 0xc3, 0xa7, 0x4a, 0x80, 0xe6, 0x4e, 0x73, 0x7a, 0x4b, 0x2a, 0x78, 0xfb, 0xe9,
      0xea, 0x5f, 0x5e, 0x73, 0x47, 0xd1, 0xa2, 0xed, 0xbe, 0x50, 0xcb, 0xf0, 0x46, 0x9c, 0x78,
      0x1c, 0xd4, 0x95, 0x2e, 0x1c, 0x23, 0x0a, 0xcf, 0xf8, 0xbe, 0x94, 0xad, 0x92, 0x2e, 0x2b,
      0x8e, 0x6e, 0xe1, 0x92, 0xba, 0xba, 0x93, 0x9e, 0x2e, 0x26, 0x08, 0xd2, 0xc1, 0x00, 0x06,
      0x9c, 0x70, 0x87, 0x6d, 0x18, 0x03, 0x78, 0x28, 0x7e, 0x85, 0x8a, 0x29, 0x54, 0x8d, 0x7c,
      0xf9, 0x88, 0x84, 0x27, 0xaf, 0x97, 0x15, 0xd4, 0x95, 0xe8, 0xcb, 0x28, 0x2d, 0xb1, 0x7f,
      0x85, 0x66, 0x09, 0xb2, 0x34, 0x51, 0xf1, 0xf3, 0x30, 0x38, 0x27, 0x33, 0xc2, 0xf8, 0x2a,
      0x1a, 0xe8, 0x34, 0x7e, 0xbb, 0x9b, 0x3a, 0x6c, 0xb3, 0x60, 0xf8, 0xc9, 0xf4, 0x47, 0x72,
      0x12, 0xec, 0xd1, 0xfe, 0x00, 0xc1, 0xac, 0x09, 0x75, 0x0e, 0x11, 0xc8, 0xf3, 0x0f, 0xd8,
      0x62
    };
};

using tv256 = tvs<test_params_256>;

// clang-format on

TEMPLATE_TEST_CASE("ggm_forest compare against tv", "[vector com]", test_params_128,
                   test_params_192, test_params_256)
{
    return; // TODO: generate new test vectors.

    using P = TestType;
    using bavc_t = P::bavc_t;
    using VC = P::CONSTS::VEC_COM;
    constexpr auto S = P::secpar_v;
    constexpr auto TAU = P::tau_v;
    INFO("SECURITY_PARAM = " << P::secpar_bits);

    const size_t tv_num = tvs<P>::test_vectors;
    const uint8_t* tv_root_key = tvs<P>::root_key.data();
    const auto& tv_com = tvs<P>::com;
    const size_t tv_com_size = tvs<P>::com.size();
    const uint8_t* tv_com_j = tvs<P>::com_j.data();
    const uint8_t* tv_pdec_j = tvs<P>::pdec_j.data();
    const size_t tv_pdec_j_size = tvs<P>::pdec_j.size();

    std::vector<block_secpar<S>> roots(TAU);
    std::vector<block_secpar<S>> forest(bavc_t::COMMIT_NODES);
    std::vector<block_secpar<S>> leaves_sender(bavc_t::COMMIT_LEAVES);
    std::vector<block_secpar<S>> leaves_receiver(bavc_t::COMMIT_LEAVES);
    std::vector<unsigned char> hashed_leaves_sender(bavc_t::COMMIT_LEAVES * bavc_t::leaf_hash_t::hash_len);
    std::vector<unsigned char> hashed_leaves_receiver(bavc_t::COMMIT_LEAVES * bavc_t::leaf_hash_t::hash_len);
    std::vector<uint8_t> delta_bytes(bavc_t::delta_bits_v, 0);
    std::vector<uint8_t> opening(bavc_t::OPEN_SIZE);

    // set iv to 0
    block128 iv = block128::set_zero();

    // init roots (first from tv, other zero)
    memcpy(&roots[0], tv_root_key, P::secpar_bytes);
    for (size_t i = 1; i < TAU; ++i)
    {
        roots[i] = block_secpar<S>::set_zero();
    }

    // commit
    REQUIRE(tv_com_size == ((1 << VC::MAX_K) * P::leaf_hash_t::hash_len));
    bavc_t::commit_from_roots(roots.data(), iv, forest.data(), leaves_sender.data(),
                              hashed_leaves_sender.data());
    // check the hashed leaves
    {
        std::array<uint8_t, 2 * P::secpar_bytes * (1 << VC::MAX_K)> hashed_leaves_vec;
        memcpy(hashed_leaves_vec.data(), hashed_leaves_sender.data(), hashed_leaves_vec.size());
        CHECK(hashed_leaves_vec == tv_com);
    }

    for (size_t delta = 0; delta < tv_num; ++delta)
    {
        INFO("delta = " << delta);
        FAEST_ASSERT(delta < (1 << VC::MIN_K));
        for (size_t i = 0, dst = 0; i < TAU; ++i)
        {
            size_t k = i < VC::NUM_MAX_K ? VC::MAX_K : VC::MIN_K;
            expand_bits_to_bytes(&delta_bytes[dst], k, delta);
            dst += k;
        }

        const auto res_open = bavc_t::open(forest.data(), hashed_leaves_sender.data(),
                                           delta_bytes.data(), opening.data());
        REQUIRE(res_open);
        // check the opening
        {
            const size_t PATH_SIZE = P::secpar_bytes * VC::MAX_K;
            const size_t HASH_SIZE = 2 * P::secpar_bytes;
            REQUIRE((PATH_SIZE * tv_num) == tv_pdec_j_size);
            std::array<uint8_t, PATH_SIZE> path_vec;
            std::array<uint8_t, PATH_SIZE> tv_path_vec;
            memcpy(path_vec.data(), opening.data(), PATH_SIZE);
            memcpy(tv_path_vec.data(), tv_pdec_j + delta * PATH_SIZE, PATH_SIZE);
            CHECK(path_vec == tv_path_vec);
            std::array<uint8_t, HASH_SIZE> hash_vec;
            std::array<uint8_t, HASH_SIZE> tv_hash_vec;
            memcpy(hash_vec.data(), opening.data() + PATH_SIZE, HASH_SIZE);
            memcpy(tv_hash_vec.data(), tv_com_j + delta * HASH_SIZE, HASH_SIZE);
            CHECK(hash_vec == tv_hash_vec);
        }

        /// verifying the opening
        const auto res_verify =
            bavc_t::verify(iv, opening.data(), delta_bytes.data(), leaves_receiver.data(),
                           hashed_leaves_receiver.data());
        REQUIRE(res_verify);

        const auto hashed_leaves_sender_bytes =
            std::vector(reinterpret_cast<arr_leaf_hash<bavc_t>*>(hashed_leaves_sender.data()),
                        reinterpret_cast<arr_leaf_hash<bavc_t>*>(hashed_leaves_sender.data() +
                                                                 hashed_leaves_sender.size()));
        const auto hashed_leaves_receiver_bytes =
            std::vector(reinterpret_cast<arr_leaf_hash<bavc_t>*>(hashed_leaves_receiver.data()),
                        reinterpret_cast<arr_leaf_hash<bavc_t>*>(hashed_leaves_receiver.data() +
                                                                 hashed_leaves_receiver.size()));
        REQUIRE(hashed_leaves_receiver_bytes == hashed_leaves_sender_bytes);
    }

    // vector_verify(opening.data(), delta_bytes.data(), leaves_receiver.data(),
    // hashed_leaves_receiver.data());
}

TEMPLATE_TEST_CASE("bacv compare against tv", "[vector com]", ALL_FAEST_V2_INSTANCES)
{
    using P = TestType;
    using bavc_t = P::bavc_t;
    constexpr auto S = bavc_t::secpar_v;
    using VC = bavc_t::CONSTS;
    constexpr auto TAU = bavc_t::tau_v;
    constexpr auto VOLE_WIDTH_SHIFT = bavc_t::vole_width_shift_v;
    using TVS = bavc_tvs<P>;

    const auto hash_buf = [](const void* buf, size_t n)
    {
        std::array<uint8_t, 64> output;
        hash_state hasher;
        hasher.init(secpar::s256);
        hasher.update(buf, n);
        hasher.finalize(output.data(), output.size());
        return output;
    };

    block_secpar<S> seed;
    memcpy(&seed, TVS::seed.data(), sizeof(seed));
    block128 iv;
    memcpy(&iv, TVS::iv.data(), sizeof(iv));

    std::array<uint8_t, P::CONSTS::VOLE_COMMIT_CHECK_SIZE> commitment_h;
    std::vector<block_secpar<S>> forest(bavc_t::COMMIT_NODES);
    std::vector<block_secpar<S>> permuted_leaves_sender(bavc_t::COMMIT_LEAVES);
    std::vector<block_secpar<S>> leaves_sender(bavc_t::COMMIT_LEAVES);
    std::vector<block_secpar<S>> permuted_leaves_receiver(bavc_t::COMMIT_LEAVES);
    std::vector<block_secpar<S>> leaves_receiver(bavc_t::COMMIT_LEAVES);
    std::vector<unsigned char> hashed_leaves_sender(bavc_t::COMMIT_LEAVES *
                                                    bavc_t::leaf_hash_t::hash_len);
    std::vector<unsigned char> hashed_leaves_receiver(bavc_t::COMMIT_LEAVES *
                                                      bavc_t::leaf_hash_t::hash_len);

    // std::array<uint8_t, bavc_t::delta_bytes_v> delta = {0};
    std::array<uint8_t, bavc_t::delta_bits_v> delta_bytes = {0};
    std::vector<uint8_t> opening(bavc_t::OPEN_SIZE);

    bavc_t::commit(seed, iv, forest.data(), permuted_leaves_sender.data(),
                   hashed_leaves_sender.data());

    for (size_t i = 0, offset = 0; i < TAU; ++i)
    {
        size_t k = i < VC::NUM_MAX_K ? VC::MAX_K : VC::MIN_K;
        for (size_t j = 0; j < (size_t)1 << k; ++j)
            leaves_sender[offset + j] =
                permuted_leaves_sender[offset +
                                       vole_permute_key_index_inv<VOLE_WIDTH_SHIFT, VC::MAX_K>(j)];
        offset += (size_t)1 << k;
    }

    hash_hashed_leaves<P>(hashed_leaves_sender.data(), commitment_h.data());
    REQUIRE(commitment_h == TVS::h);

    const auto hashed_sd =
        hash_buf(leaves_sender.data(), leaves_sender.size() * sizeof(leaves_sender[0]));
    REQUIRE(hashed_sd == TVS::hashed_sd);

    const auto hashed_k = hash_buf(forest.data(), forest.size() * sizeof(forest[0]));
    REQUIRE(hashed_k == TVS::hashed_k);

    for (size_t i = 0, offset = 0; i < TAU; ++i)
    {
        size_t k = i < VC::NUM_MAX_K ? VC::MAX_K : VC::MIN_K;
        for (size_t j = 0; j < k; ++j)
            delta_bytes[offset + j] = (TVS::i_delta[i] & (1 << j)) ? 0xff : 0x00;

        offset += k;
    }

    const auto res_open = bavc_t::open(forest.data(), hashed_leaves_sender.data(),
                                       delta_bytes.data(), opening.data());
    REQUIRE(res_open);
    const auto hashed_decom_i = hash_buf(opening.data(), opening.size() * sizeof(opening[0]));
    REQUIRE(hashed_decom_i == TVS::hashed_decom_i);

    const auto res_verify =
        bavc_t::verify(iv, opening.data(), delta_bytes.data(), permuted_leaves_receiver.data(),
                       hashed_leaves_receiver.data());
    REQUIRE(res_verify);

    hash_state hasher;
    hasher.init(secpar::s256);
    for (size_t i = 0, offset = 0; i < TAU; ++i)
    {
        INFO("i = " << i << ", Delta_" << i << " = " << TVS::i_delta[i]);
        size_t k = i < VC::NUM_MAX_K ? VC::MAX_K : VC::MIN_K;
        for (size_t j = 0; j < (size_t)1 << k; ++j)
        {
            leaves_receiver[offset + j] =
                permuted_leaves_receiver[offset +
                                         vole_permute_key_index_inv<VOLE_WIDTH_SHIFT, VC::MAX_K>(
                                             j ^ TVS::i_delta[i])];
            if (j != TVS::i_delta[i])
            {
                INFO("j = " << j);
                REQUIRE(leaves_receiver[offset + j] == leaves_sender[offset + j]);
                hasher.update(&leaves_receiver[offset + j], sizeof(leaves_receiver[offset + j]));
            }
        }
        offset += (size_t)1 << k;
    }

    std::array<uint8_t, 64> hashed_rec_sd;
    hasher.finalize(hashed_rec_sd.data(), hashed_rec_sd.size());
    hash_buf(leaves_receiver.data(), leaves_receiver.size() * sizeof(leaves_receiver[0]));
    REQUIRE(hashed_rec_sd == TVS::hashed_rec_sd);
}
